% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/do.R
\name{do.RxFileData}
\alias{do.RxFileData}
\alias{do}
\alias{do.grouped_tbl_xdf}
\alias{do_xdf}
\alias{doXdf}
\alias{do_xdf.RxFileData}
\alias{do_xdf.grouped_tbl_xdf}
\title{Do arbitrary operations on a tbl}
\usage{
\method{do}{RxFileData}(.data, ...)

\method{do}{grouped_tbl_xdf}(.data, ...)

do_xdf(.data, ...)

doXdf(.data, ...)

\method{do_xdf}{RxFileData}(.data, ...)

\method{do_xdf}{grouped_tbl_xdf}(.data, ...)
}
\arguments{
\item{.data}{A tbl for an Xdf data source; or a raw Xdf data source.}

\item{...}{Expressions to apply.}
}
\value{
The \code{do} and \code{do_xdf} verbs always return a data frame, unlike the other verbs for Xdf objects. This is because they are meant to execute code that can return arbitrarily complex objects, and Xdf files can only store atomic data.
}
\description{
The \code{do} verb converts the data to a data frame before running the operations. The \code{doXdf} verb keeps the data in Xdf format, so is not (as) limited by memory.
}
\details{
The difference between the \code{do} and \code{do_xdf} verbs is that the former converts the data into a data frame before running the expressions on it; while the latter passes the data as Xdf files. \code{do} is thus more flexible in the expressions it can run (basically anything that works with data frames), whereas \code{do_xdf} is better able to handle large datasets. The final output from \code{do_xdf} must still be able to fit in memory (see below).

\code{do_xdf} was called \code{doXdf} in previous versions of this package; it has been renamed to match dplyr's snake_case naming convention.

To run expressions on a grouped Xdf tbl, \code{do} and \code{do_xdf} split the data into one file per group, and the arguments are called on each file. Note however this may be slow if you have a large number of groups; and, for \code{do}, the operation will be limited by memory if the number of rows per group is large.
}
\examples{
# unnamed arg
mtx <- as_xdf(mtcars)
do(mtx, {
    mpg2 <- 2 * .$mpg
    cyl2 <- 2 * .$cyl
})

# named arg
do(mtx, m=lm(mpg ~ cyl, data=.)

# fitting multiple models to subsets of the data
if(require("nycflights13")) {
flx <- as_xdf(flights, overwrite=TRUE)
flx \%>\%
    group_by(carrier) \%>\%
    do(m=lm(arr_delay ~ dep_time, data=.))

# with do_xdf: useful if each subset is very large, but called code must be Xdf-aware
flx \%>\%
    group_by(carrier) \%>\%
    do_xdf(m2=rxLinMod(arr_delay ~ dep_time, data=.)
}
}
\seealso{
\code{\link[dplyr]{do}} in package dplyr
}
